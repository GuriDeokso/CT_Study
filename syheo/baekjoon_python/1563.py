#solved.ac
#골드4
#다이나믹 프로그래밍
#개근상
#1563

# 아이디어 
# 처음엔 수학적 접근으로 할려고 했다. -> 어려움 
# 두번째로는 2회이상 or 결석 3번 연속 사람의 합을 전체 합에서 빼서 답을 내려고 했다.
# 하지만 그럴 경우 합집합의 경우 교집합을 빼줘야 하는 번거로움이 있기에 교집합의 조건(2회 미만 , 결석 3번 연속 미만)을 찾기로 함.

# 개근상을 받을 수 없는 사람은 지각을 두 번 이상 했거나, 결석을 세 번 연속으로 한 사람 
# 지각을 두 번 이하로 하고, 결석을 세번 연속으로 안한 사람 -> 개근상 

# late 
# absent

N = int(input())

late_dp = [[0]*3 for _ in range(N+1)] # 학기 요일 별로 지각 횟수 저장 
absent_dp = [[0]*3 for _ in range(N+1)] # 학기 요일 별로 결석 3연속 횟수 저장 
# 2차원 인덱스 [0] -> 지각 0번 ,2차원 인덱스 [1] -> 지각 1번 
# 3차원 인덱스 [0] -> 결석 0번 ,3차원 인덱스 [1] -> 결석 연속 1번 ,3차원 인덱스 [2] -> 결석 연속 2번
dp = [[[0]*3 for _ in range(2)]for _ in range(N+1)]

#지각 2회 이상 체크 
# late_dp[i][0] = 2**i
# late_dp[i][1] = late_dp[i-1][0]+late_dp[i-1][1]*2
# late_dp[i][2] = late_dp[i-1][1]+late_dp[i-1][2]


# O A L 
# OAL OAL OAL 
dp[1][0][0]=1
dp[1][0][1]=1
dp[1][0][2]=0
dp[1][1][0]=1
dp[1][1][1]=0
dp[1][1][2]=0


for i in range(2,N+1):
    #지각 2회 미만 and 결석 3번 불연속 체크 
    dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2]
    dp[i][0][1]=dp[i-1][0][0]
    dp[i][0][2]=dp[i-1][0][1]
    dp[i][1][0]=dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2]+dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2]
    dp[i][1][1]=dp[i-1][1][0]
    dp[i][1][2]=dp[i-1][1][1]

answer = 0
for i in range(2):
    for j in range(3):
        answer += dp[N][i][j]

print(answer%1000000)
